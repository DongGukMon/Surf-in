{"ast":null,"code":"import _regeneratorRuntime from\"@babel/runtime/regenerator\";import{UnavailabilityError}from'@unimodules/core';import ExpoSecureStore from\"./ExpoSecureStore\";export var AFTER_FIRST_UNLOCK=ExpoSecureStore.AFTER_FIRST_UNLOCK;export var AFTER_FIRST_UNLOCK_THIS_DEVICE_ONLY=ExpoSecureStore.AFTER_FIRST_UNLOCK_THIS_DEVICE_ONLY;export var ALWAYS=ExpoSecureStore.ALWAYS;export var WHEN_PASSCODE_SET_THIS_DEVICE_ONLY=ExpoSecureStore.WHEN_PASSCODE_SET_THIS_DEVICE_ONLY;export var ALWAYS_THIS_DEVICE_ONLY=ExpoSecureStore.ALWAYS_THIS_DEVICE_ONLY;export var WHEN_UNLOCKED=ExpoSecureStore.WHEN_UNLOCKED;export var WHEN_UNLOCKED_THIS_DEVICE_ONLY=ExpoSecureStore.WHEN_UNLOCKED_THIS_DEVICE_ONLY;var VALUE_BYTES_LIMIT=2048;export function isAvailableAsync(){return _regeneratorRuntime.async(function isAvailableAsync$(_context){while(1){switch(_context.prev=_context.next){case 0:return _context.abrupt(\"return\",!!ExpoSecureStore.getValueWithKeyAsync);case 1:case\"end\":return _context.stop();}}},null,null,null,Promise);}export function deleteItemAsync(key){var options,_args2=arguments;return _regeneratorRuntime.async(function deleteItemAsync$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:options=_args2.length>1&&_args2[1]!==undefined?_args2[1]:{};_ensureValidKey(key);if(ExpoSecureStore.deleteValueWithKeyAsync){_context2.next=4;break;}throw new UnavailabilityError('SecureStore','deleteItemAsync');case 4:_context2.next=6;return _regeneratorRuntime.awrap(ExpoSecureStore.deleteValueWithKeyAsync(key,options));case 6:case\"end\":return _context2.stop();}}},null,null,null,Promise);}export function getItemAsync(key){var options,_args3=arguments;return _regeneratorRuntime.async(function getItemAsync$(_context3){while(1){switch(_context3.prev=_context3.next){case 0:options=_args3.length>1&&_args3[1]!==undefined?_args3[1]:{};_ensureValidKey(key);_context3.next=4;return _regeneratorRuntime.awrap(ExpoSecureStore.getValueWithKeyAsync(key,options));case 4:return _context3.abrupt(\"return\",_context3.sent);case 5:case\"end\":return _context3.stop();}}},null,null,null,Promise);}export function setItemAsync(key,value){var options,_args4=arguments;return _regeneratorRuntime.async(function setItemAsync$(_context4){while(1){switch(_context4.prev=_context4.next){case 0:options=_args4.length>2&&_args4[2]!==undefined?_args4[2]:{};_ensureValidKey(key);if(_isValidValue(value)){_context4.next=4;break;}throw new Error(\"Invalid value provided to SecureStore. Values must be strings; consider JSON-encoding your values if they are serializable.\");case 4:if(ExpoSecureStore.setValueWithKeyAsync){_context4.next=6;break;}throw new UnavailabilityError('SecureStore','setItemAsync');case 6:_context4.next=8;return _regeneratorRuntime.awrap(ExpoSecureStore.setValueWithKeyAsync(value,key,options));case 8:case\"end\":return _context4.stop();}}},null,null,null,Promise);}function _ensureValidKey(key){if(!_isValidKey(key)){throw new Error(\"Invalid key provided to SecureStore. Keys must not be empty and contain only alphanumeric characters, \\\".\\\", \\\"-\\\", and \\\"_\\\".\");}}function _isValidKey(key){return typeof key==='string'&&/^[\\w.-]+$/.test(key);}function _isValidValue(value){if(typeof value!=='string'){return false;}if(_byteCount(value)>VALUE_BYTES_LIMIT){console.warn('Provided value to SecureStore is larger than 2048 bytes. An attempt to store such a value will throw an error in SDK 35.');}return true;}function _byteCount(value){var bytes=0;for(var i=0;i<value.length;i++){var codePoint=value.charCodeAt(i);if(codePoint>=0xd800&&codePoint<0xe000){if(codePoint<0xdc00&&i+1<value.length){var next=value.charCodeAt(i+1);if(next>=0xdc00&&next<0xe000){bytes+=4;i++;continue;}}}bytes+=codePoint<0x80?1:codePoint<0x800?2:3;}return bytes;}","map":{"version":3,"sources":["../src/SecureStore.ts"],"names":[],"mappings":"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","sourcesContent":["import { UnavailabilityError } from '@unimodules/core';\n\nimport ExpoSecureStore from './ExpoSecureStore';\n\nexport type KeychainAccessibilityConstant = number;\n\n// @needsAudit\n/**\n * The data in the keychain item cannot be accessed after a restart until the device has been\n * unlocked once by the user. This may be useful if you need to access the item when the phone\n * is locked.\n */\nexport const AFTER_FIRST_UNLOCK: KeychainAccessibilityConstant = ExpoSecureStore.AFTER_FIRST_UNLOCK;\n\n// @needsAudit\n/**\n * Similar to `AFTER_FIRST_UNLOCK`, except the entry is not migrated to a new device when restoring\n * from a backup.\n */\nexport const AFTER_FIRST_UNLOCK_THIS_DEVICE_ONLY: KeychainAccessibilityConstant =\n  ExpoSecureStore.AFTER_FIRST_UNLOCK_THIS_DEVICE_ONLY;\n\n// @needsAudit\n/**\n * The data in the keychain item can always be accessed regardless of whether the device is locked.\n * This is the least secure option.\n */\nexport const ALWAYS: KeychainAccessibilityConstant = ExpoSecureStore.ALWAYS;\n\n// @needsAudit\n/**\n * Similar to `WHEN_UNLOCKED_THIS_DEVICE_ONLY`, except the user must have set a passcode in order to\n * store an entry. If the user removes their passcode, the entry will be deleted.\n */\nexport const WHEN_PASSCODE_SET_THIS_DEVICE_ONLY: KeychainAccessibilityConstant =\n  ExpoSecureStore.WHEN_PASSCODE_SET_THIS_DEVICE_ONLY;\n\n// @needsAudit\n/**\n * Similar to `ALWAYS`, except the entry is not migrated to a new device when restoring from a backup.\n */\nexport const ALWAYS_THIS_DEVICE_ONLY: KeychainAccessibilityConstant =\n  ExpoSecureStore.ALWAYS_THIS_DEVICE_ONLY;\n\n// @needsAudit\n/**\n * The data in the keychain item can be accessed only while the device is unlocked by the user.\n */\nexport const WHEN_UNLOCKED: KeychainAccessibilityConstant = ExpoSecureStore.WHEN_UNLOCKED;\n\n// @needsAudit\n/**\n * Similar to `WHEN_UNLOCKED`, except the entry is not migrated to a new device when restoring from\n * a backup.\n */\nexport const WHEN_UNLOCKED_THIS_DEVICE_ONLY: KeychainAccessibilityConstant =\n  ExpoSecureStore.WHEN_UNLOCKED_THIS_DEVICE_ONLY;\n\nconst VALUE_BYTES_LIMIT = 2048;\n\n// @needsAudit\nexport type SecureStoreOptions = {\n  /**\n   * - iOS: The item's service, equivalent to `kSecAttrService`\n   * - Android: Equivalent of the public/private key pair `Alias`\n   * > If the item is set with the `keychainService` option, it will be required to later fetch the value.\n   */\n  keychainService?: string;\n  /**\n   * __(iOS only)__ Specifies when the stored entry is accessible, using iOS's `kSecAttrAccessible`\n   * property. See Apple's documentation on [keychain item accessibility](https://developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/02concepts/concepts.html#//apple_ref/doc/uid/TP30000897-CH204-SW18).\n   * Default value: `SecureStore.WHEN_UNLOCKED`.\n   */\n  keychainAccessible?: KeychainAccessibilityConstant;\n};\n\n// @needsAudit\n/**\n * Returns whether the SecureStore API is enabled on the current device. This does not check the app\n * permissions.\n *\n * @return Promise which fulfils witch `boolean`, indicating whether the SecureStore API is available\n * on the current device. Currently this resolves `true` on iOS and Android only.\n */\nexport async function isAvailableAsync(): Promise<boolean> {\n  return !!ExpoSecureStore.getValueWithKeyAsync;\n}\n\n// @needsAudit\n/**\n * Delete the value associated with the provided key.\n *\n * @param key The key that was used to store the associated value.\n * @param options An [`SecureStoreOptions`](#securestoreoptions) object.\n *\n * @return A promise that will reject if the value couldn't be deleted.\n */\nexport async function deleteItemAsync(\n  key: string,\n  options: SecureStoreOptions = {}\n): Promise<void> {\n  _ensureValidKey(key);\n\n  if (!ExpoSecureStore.deleteValueWithKeyAsync) {\n    throw new UnavailabilityError('SecureStore', 'deleteItemAsync');\n  }\n  await ExpoSecureStore.deleteValueWithKeyAsync(key, options);\n}\n\n// @needsAudit\n/**\n * Fetch the stored value associated with the provided key.\n *\n * @param key The key that was used to store the associated value.\n * @param options An [`SecureStoreOptions`](#securestoreoptions) object.\n *\n * @return A promise that resolves to the previously stored value, or `null` if there is no entry\n * for the given key. The promise will reject if an error occurred while retrieving the value.\n */\nexport async function getItemAsync(\n  key: string,\n  options: SecureStoreOptions = {}\n): Promise<string | null> {\n  _ensureValidKey(key);\n  return await ExpoSecureStore.getValueWithKeyAsync(key, options);\n}\n\n// @needsAudit\n/**\n * Store a key–value pair.\n *\n * @param key The key to associate with the stored value. Keys may contain alphanumeric characters\n * `.`, `-`, and `_`.\n * @param value The value to store. Size limit is 2048 bytes.\n * @param options An [`SecureStoreOptions`](#securestoreoptions) object.\n *\n * @return A promise that will reject if value cannot be stored on the device.\n */\nexport async function setItemAsync(\n  key: string,\n  value: string,\n  options: SecureStoreOptions = {}\n): Promise<void> {\n  _ensureValidKey(key);\n  if (!_isValidValue(value)) {\n    throw new Error(\n      `Invalid value provided to SecureStore. Values must be strings; consider JSON-encoding your values if they are serializable.`\n    );\n  }\n  if (!ExpoSecureStore.setValueWithKeyAsync) {\n    throw new UnavailabilityError('SecureStore', 'setItemAsync');\n  }\n  await ExpoSecureStore.setValueWithKeyAsync(value, key, options);\n}\n\nfunction _ensureValidKey(key: string) {\n  if (!_isValidKey(key)) {\n    throw new Error(\n      `Invalid key provided to SecureStore. Keys must not be empty and contain only alphanumeric characters, \".\", \"-\", and \"_\".`\n    );\n  }\n}\n\nfunction _isValidKey(key: string) {\n  return typeof key === 'string' && /^[\\w.-]+$/.test(key);\n}\n\nfunction _isValidValue(value: string) {\n  if (typeof value !== 'string') {\n    return false;\n  }\n  if (_byteCount(value) > VALUE_BYTES_LIMIT) {\n    console.warn(\n      'Provided value to SecureStore is larger than 2048 bytes. An attempt to store such a value will throw an error in SDK 35.'\n    );\n  }\n  return true;\n}\n\n// copy-pasted from https://stackoverflow.com/a/39488643\nfunction _byteCount(value: string) {\n  let bytes = 0;\n\n  for (let i = 0; i < value.length; i++) {\n    const codePoint = value.charCodeAt(i);\n\n    // Lone surrogates cannot be passed to encodeURI\n    if (codePoint >= 0xd800 && codePoint < 0xe000) {\n      if (codePoint < 0xdc00 && i + 1 < value.length) {\n        const next = value.charCodeAt(i + 1);\n\n        if (next >= 0xdc00 && next < 0xe000) {\n          bytes += 4;\n          i++;\n          continue;\n        }\n      }\n    }\n\n    bytes += codePoint < 0x80 ? 1 : codePoint < 0x800 ? 2 : 3;\n  }\n\n  return bytes;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}