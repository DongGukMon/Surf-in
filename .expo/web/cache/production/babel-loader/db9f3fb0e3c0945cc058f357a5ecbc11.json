{"ast":null,"code":"import _regeneratorRuntime from\"@babel/runtime/regenerator\";import{Platform,CodedError,UnavailabilityError}from'@unimodules/core';import*as Application from'expo-application';import Constants from'expo-constants';import{setAutoServerRegistrationEnabledAsync}from\"./DevicePushTokenAutoRegistration.fx\";import ServerRegistrationModule from\"./ServerRegistrationModule\";import getDevicePushTokenAsync from\"./getDevicePushTokenAsync\";var productionBaseUrl='https://exp.host/--/api/v2/';export default function getExpoPushTokenAsync(){var _Constants$manifest,_Constants$manifest2,_options$baseUrl,_options$url;var options,devicePushToken,deviceId,experienceId,applicationId,type,development,baseUrl,url,body,response,statusInfo,_body,expoPushToken,_args=arguments;return _regeneratorRuntime.async(function getExpoPushTokenAsync$(_context){while(1){switch(_context.prev=_context.next){case 0:options=_args.length>0&&_args[0]!==undefined?_args[0]:{};_context.t0=options.devicePushToken;if(_context.t0){_context.next=6;break;}_context.next=5;return _regeneratorRuntime.awrap(getDevicePushTokenAsync());case 5:_context.t0=_context.sent;case 6:devicePushToken=_context.t0;_context.t1=options.deviceId;if(_context.t1){_context.next=12;break;}_context.next=11;return _regeneratorRuntime.awrap(getDeviceIdAsync());case 11:_context.t1=_context.sent;case 12:deviceId=_context.t1;experienceId=options.experienceId||((_Constants$manifest=Constants.manifest)==null?void 0:_Constants$manifest.originalFullName)||((_Constants$manifest2=Constants.manifest)==null?void 0:_Constants$manifest2.id);if(experienceId){_context.next=16;break;}throw new CodedError('ERR_NOTIFICATIONS_NO_EXPERIENCE_ID',\"No experienceId found. If it can't be inferred from the manifest (eg. in bare workflow), you have to pass it in yourself.\");case 16:applicationId=options.applicationId||Application.applicationId;if(applicationId){_context.next=19;break;}throw new CodedError('ERR_NOTIFICATIONS_NO_APPLICATION_ID',\"No applicationId found. If it can't be inferred from native configuration by expo-application, you have to pass it in yourself.\");case 19:type=options.type||getTypeOfToken(devicePushToken);_context.t2=options.development;if(_context.t2){_context.next=25;break;}_context.next=24;return _regeneratorRuntime.awrap(shouldUseDevelopmentNotificationService());case 24:_context.t2=_context.sent;case 25:development=_context.t2;baseUrl=(_options$baseUrl=options.baseUrl)!=null?_options$baseUrl:productionBaseUrl;url=(_options$url=options.url)!=null?_options$url:baseUrl+\"push/getExpoPushToken\";body={type:type,deviceId:deviceId,development:development,experienceId:experienceId,appId:applicationId,deviceToken:getDeviceToken(devicePushToken)};_context.next=31;return _regeneratorRuntime.awrap(fetch(url,{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify(body)}).catch(function(error){throw new CodedError('ERR_NOTIFICATIONS_NETWORK_ERROR',\"Error encountered while fetching Expo token: \"+error+\".\");}));case 31:response=_context.sent;if(response.ok){_context.next=44;break;}statusInfo=response.statusText||response.status;_body=undefined;_context.prev=35;_context.next=38;return _regeneratorRuntime.awrap(response.text());case 38:_body=_context.sent;_context.next=43;break;case 41:_context.prev=41;_context.t3=_context[\"catch\"](35);case 43:throw new CodedError('ERR_NOTIFICATIONS_SERVER_ERROR',\"Error encountered while fetching Expo token, expected an OK response, received: \"+statusInfo+\" (body: \\\"\"+_body+\"\\\").\");case 44:_context.t4=getExpoPushToken;_context.next=47;return _regeneratorRuntime.awrap(parseResponse(response));case 47:_context.t5=_context.sent;expoPushToken=(0,_context.t4)(_context.t5);_context.prev=49;if(!(options.url||options.baseUrl)){_context.next=54;break;}console.debug(\"[expo-notifications] Since the URL endpoint to register in has been customized in the options, expo-notifications won't try to auto-update the device push token on the server.\");_context.next=56;break;case 54:_context.next=56;return _regeneratorRuntime.awrap(setAutoServerRegistrationEnabledAsync(true));case 56:_context.next=61;break;case 58:_context.prev=58;_context.t6=_context[\"catch\"](49);console.warn('[expo-notifications] Could not enable automatically registering new device tokens with the Expo notification service',_context.t6);case 61:return _context.abrupt(\"return\",{type:'expo',data:expoPushToken});case 62:case\"end\":return _context.stop();}}},null,null,[[35,41],[49,58]],Promise);}function parseResponse(response){return _regeneratorRuntime.async(function parseResponse$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:_context2.prev=0;_context2.next=3;return _regeneratorRuntime.awrap(response.json());case 3:return _context2.abrupt(\"return\",_context2.sent);case 6:_context2.prev=6;_context2.t0=_context2[\"catch\"](0);_context2.prev=8;_context2.t1=CodedError;_context2.t2=JSON;_context2.next=13;return _regeneratorRuntime.awrap(response.text());case 13:_context2.t3=_context2.sent;_context2.t4=_context2.t2.stringify.call(_context2.t2,_context2.t3);_context2.t5=\"Expected a JSON response from server when fetching Expo token, received body: \"+_context2.t4;_context2.t6=_context2.t5+\".\";throw new _context2.t1('ERR_NOTIFICATIONS_SERVER_ERROR',_context2.t6);case 20:_context2.prev=20;_context2.t7=_context2[\"catch\"](8);throw new CodedError('ERR_NOTIFICATIONS_SERVER_ERROR',\"Expected a JSON response from server when fetching Expo token, received response: \"+JSON.stringify(response)+\".\");case 23:case\"end\":return _context2.stop();}}},null,null,[[0,6],[8,20]],Promise);}function getExpoPushToken(data){if(!data||!(typeof data==='object')||!data.data||!(typeof data.data==='object')||!data.data.expoPushToken||!(typeof data.data.expoPushToken==='string')){throw new CodedError('ERR_NOTIFICATIONS_SERVER_ERROR',\"Malformed response from server, expected \\\"{ data: { expoPushToken: string } }\\\", received: \"+JSON.stringify(data,null,2)+\".\");}return data.data.expoPushToken;}function getDeviceIdAsync(){return _regeneratorRuntime.async(function getDeviceIdAsync$(_context3){while(1){switch(_context3.prev=_context3.next){case 0:_context3.prev=0;if(ServerRegistrationModule.getInstallationIdAsync){_context3.next=3;break;}throw new UnavailabilityError('ExpoServerRegistrationModule','getInstallationIdAsync');case 3:_context3.next=5;return _regeneratorRuntime.awrap(ServerRegistrationModule.getInstallationIdAsync());case 5:return _context3.abrupt(\"return\",_context3.sent);case 8:_context3.prev=8;_context3.t0=_context3[\"catch\"](0);throw new CodedError('ERR_NOTIF_DEVICE_ID',\"Could not have fetched installation ID of the application: \"+_context3.t0+\".\");case 11:case\"end\":return _context3.stop();}}},null,null,[[0,8]],Promise);}function getDeviceToken(devicePushToken){if(typeof devicePushToken.data==='string'){return devicePushToken.data;}return JSON.stringify(devicePushToken.data);}function shouldUseDevelopmentNotificationService(){var notificationServiceEnvironment;return _regeneratorRuntime.async(function shouldUseDevelopmentNotificationService$(_context4){while(1){switch(_context4.prev=_context4.next){case 0:if(!(Platform.OS==='ios')){_context4.next=11;break;}_context4.prev=1;_context4.next=4;return _regeneratorRuntime.awrap(Application.getIosPushNotificationServiceEnvironmentAsync());case 4:notificationServiceEnvironment=_context4.sent;if(!(notificationServiceEnvironment==='development')){_context4.next=7;break;}return _context4.abrupt(\"return\",true);case 7:_context4.next=11;break;case 9:_context4.prev=9;_context4.t0=_context4[\"catch\"](1);case 11:return _context4.abrupt(\"return\",false);case 12:case\"end\":return _context4.stop();}}},null,null,[[1,9]],Promise);}function getTypeOfToken(devicePushToken){switch(devicePushToken.type){case'ios':return'apns';case'android':return'fcm';default:return devicePushToken.type;}}","map":{"version":3,"sources":["../src/getExpoPushTokenAsync.ts"],"names":[],"mappings":"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","sourcesContent":["import { Platform, CodedError, UnavailabilityError } from '@unimodules/core';\nimport * as Application from 'expo-application';\nimport Constants from 'expo-constants';\n\nimport { setAutoServerRegistrationEnabledAsync } from './DevicePushTokenAutoRegistration.fx';\nimport ServerRegistrationModule from './ServerRegistrationModule';\nimport { DevicePushToken, ExpoPushToken } from './Tokens.types';\nimport getDevicePushTokenAsync from './getDevicePushTokenAsync';\n\nconst productionBaseUrl = 'https://exp.host/--/api/v2/';\n\ninterface Options {\n  // Endpoint URL override\n  baseUrl?: string;\n\n  // Request URL override\n  url?: string;\n\n  // Request body overrides\n  type?: string;\n  deviceId?: string;\n  development?: boolean;\n  experienceId?: string;\n  applicationId?: string;\n  devicePushToken?: DevicePushToken;\n}\n\nexport default async function getExpoPushTokenAsync(options: Options = {}): Promise<ExpoPushToken> {\n  const devicePushToken = options.devicePushToken || (await getDevicePushTokenAsync());\n\n  const deviceId = options.deviceId || (await getDeviceIdAsync());\n\n  const experienceId =\n    options.experienceId || Constants.manifest?.originalFullName || Constants.manifest?.id;\n\n  if (!experienceId) {\n    throw new CodedError(\n      'ERR_NOTIFICATIONS_NO_EXPERIENCE_ID',\n      \"No experienceId found. If it can't be inferred from the manifest (eg. in bare workflow), you have to pass it in yourself.\"\n    );\n  }\n\n  const applicationId = options.applicationId || Application.applicationId;\n  if (!applicationId) {\n    throw new CodedError(\n      'ERR_NOTIFICATIONS_NO_APPLICATION_ID',\n      \"No applicationId found. If it can't be inferred from native configuration by expo-application, you have to pass it in yourself.\"\n    );\n  }\n  const type = options.type || getTypeOfToken(devicePushToken);\n  const development = options.development || (await shouldUseDevelopmentNotificationService());\n\n  const baseUrl = options.baseUrl ?? productionBaseUrl;\n  const url = options.url ?? `${baseUrl}push/getExpoPushToken`;\n\n  const body = {\n    type,\n    deviceId,\n    development,\n    experienceId,\n    appId: applicationId,\n    deviceToken: getDeviceToken(devicePushToken),\n  };\n\n  const response = await fetch(url, {\n    method: 'POST',\n    headers: {\n      'content-type': 'application/json',\n    },\n    body: JSON.stringify(body),\n  }).catch(error => {\n    throw new CodedError(\n      'ERR_NOTIFICATIONS_NETWORK_ERROR',\n      `Error encountered while fetching Expo token: ${error}.`\n    );\n  });\n\n  if (!response.ok) {\n    const statusInfo = response.statusText || response.status;\n    let body: string | undefined = undefined;\n    try {\n      body = await response.text();\n    } catch (error) {\n      // do nothing\n    }\n    throw new CodedError(\n      'ERR_NOTIFICATIONS_SERVER_ERROR',\n      `Error encountered while fetching Expo token, expected an OK response, received: ${statusInfo} (body: \"${body}\").`\n    );\n  }\n\n  const expoPushToken = getExpoPushToken(await parseResponse(response));\n\n  try {\n    if (options.url || options.baseUrl) {\n      console.debug(\n        `[expo-notifications] Since the URL endpoint to register in has been customized in the options, expo-notifications won't try to auto-update the device push token on the server.`\n      );\n    } else {\n      await setAutoServerRegistrationEnabledAsync(true);\n    }\n  } catch (e) {\n    console.warn(\n      '[expo-notifications] Could not enable automatically registering new device tokens with the Expo notification service',\n      e\n    );\n  }\n\n  return {\n    type: 'expo',\n    data: expoPushToken,\n  };\n}\n\nasync function parseResponse(response: Response) {\n  try {\n    return await response.json();\n  } catch (error) {\n    try {\n      throw new CodedError(\n        'ERR_NOTIFICATIONS_SERVER_ERROR',\n        `Expected a JSON response from server when fetching Expo token, received body: ${JSON.stringify(\n          await response.text()\n        )}.`\n      );\n    } catch (innerError) {\n      throw new CodedError(\n        'ERR_NOTIFICATIONS_SERVER_ERROR',\n        `Expected a JSON response from server when fetching Expo token, received response: ${JSON.stringify(\n          response\n        )}.`\n      );\n    }\n  }\n}\n\nfunction getExpoPushToken(data: any) {\n  if (\n    !data ||\n    !(typeof data === 'object') ||\n    !data.data ||\n    !(typeof data.data === 'object') ||\n    !data.data.expoPushToken ||\n    !(typeof data.data.expoPushToken === 'string')\n  ) {\n    throw new CodedError(\n      'ERR_NOTIFICATIONS_SERVER_ERROR',\n      `Malformed response from server, expected \"{ data: { expoPushToken: string } }\", received: ${JSON.stringify(\n        data,\n        null,\n        2\n      )}.`\n    );\n  }\n\n  return data.data.expoPushToken as string;\n}\n\n// Same as in DevicePushTokenAutoRegistration\nasync function getDeviceIdAsync() {\n  try {\n    if (!ServerRegistrationModule.getInstallationIdAsync) {\n      throw new UnavailabilityError('ExpoServerRegistrationModule', 'getInstallationIdAsync');\n    }\n\n    return await ServerRegistrationModule.getInstallationIdAsync();\n  } catch (e) {\n    throw new CodedError(\n      'ERR_NOTIF_DEVICE_ID',\n      `Could not have fetched installation ID of the application: ${e}.`\n    );\n  }\n}\n\nfunction getDeviceToken(devicePushToken: DevicePushToken) {\n  if (typeof devicePushToken.data === 'string') {\n    return devicePushToken.data;\n  }\n\n  return JSON.stringify(devicePushToken.data);\n}\n\n// Same as in DevicePushTokenAutoRegistration\nasync function shouldUseDevelopmentNotificationService() {\n  if (Platform.OS === 'ios') {\n    try {\n      const notificationServiceEnvironment = await Application.getIosPushNotificationServiceEnvironmentAsync();\n      if (notificationServiceEnvironment === 'development') {\n        return true;\n      }\n    } catch (e) {\n      // We can't do anything here, we'll fallback to false then.\n    }\n  }\n\n  return false;\n}\n\n// Same as in DevicePushTokenAutoRegistration\nfunction getTypeOfToken(devicePushToken: DevicePushToken) {\n  switch (devicePushToken.type) {\n    case 'ios':\n      return 'apns';\n    case 'android':\n      return 'fcm';\n    // This probably will error on server, but let's make this function future-safe.\n    default:\n      return devicePushToken.type;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}